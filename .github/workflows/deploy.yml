name: Deploy

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - staging
          - production

permissions:
  contents: read
  id-token: write # Required for OIDC authentication with AWS

env:
  AWS_REGION: us-east-1
  LAMBDA_FUNCTION_NAME: country-service-lambda

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      lambda-jar-path: ${{ steps.build.outputs.lambda-jar-path }}
      version: ${{ steps.version.outputs.version }}
    
    steps:
      - uses: actions/checkout@v5
      
      - name: Set up JDK 21
        uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: '21'
      
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew
      
      - name: Cache Gradle dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-
      
      - name: Extract version from tag
        id: version
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
      
      - name: Build Lambda package
        id: build
        run: |
          ./gradlew :country-service-adapters:buildLambdaPackage --no-daemon
          JAR_PATH=$(find country-service-adapters/build/libs -name "country-service-lambda-*.jar" | head -1)
          echo "lambda-jar-path=$JAR_PATH" >> $GITHUB_OUTPUT
          echo "Lambda JAR: $JAR_PATH"
          ls -lh "$JAR_PATH"
      
      - name: Upload Lambda package
        uses: actions/upload-artifact@v5
        with:
          name: lambda-package
          path: ${{ steps.build.outputs.lambda-jar-path }}
          retention-days: 7

  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment:
      name: staging
      # URL can be configured in GitHub Environment settings if needed
    
    steps:
      - uses: actions/checkout@v5
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_STAGING }}
          role-session-name: GitHubActions-Deploy-Staging
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Download Lambda package
        uses: actions/download-artifact@v5
        with:
          name: lambda-package
          path: .
      
      - name: Get Lambda execution role ARN
        id: lambda_role
        run: |
          # Use secret if provided, otherwise get from CloudFormation stack or IAM
          if [ -n "${{ secrets.LAMBDA_EXECUTION_ROLE_ARN_STAGING }}" ] && [ "${{ secrets.LAMBDA_EXECUTION_ROLE_ARN_STAGING }}" != "" ]; then
            ROLE_ARN="${{ secrets.LAMBDA_EXECUTION_ROLE_ARN_STAGING }}"
            echo "Using role ARN from secret: $ROLE_ARN"
          else
            # Try to get from CloudFormation stack
            STACK_NAME="country-service-lambda-execution-roles"
            if aws cloudformation describe-stacks --stack-name "$STACK_NAME" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
              echo "Getting role ARN from CloudFormation stack..."
              ROLE_ARN=$(aws cloudformation describe-stacks \
                --stack-name "$STACK_NAME" \
                --region ${{ env.AWS_REGION }} \
                --query 'Stacks[0].Outputs[?OutputKey==`LambdaExecutionRoleArnStaging`].OutputValue' \
                --output text)
              echo "Got role ARN from CloudFormation: $ROLE_ARN"
            else
              # Fallback: try to get from IAM directly
              ROLE_NAME="country-service-lambda-execution-staging"
              if aws iam get-role --role-name "$ROLE_NAME" >/dev/null 2>&1; then
                ROLE_ARN=$(aws iam get-role --role-name "$ROLE_NAME" --query 'Role.Arn' --output text)
                echo "Got role ARN from IAM: $ROLE_ARN"
              else
                echo "❌ Error: Lambda execution role not found"
                echo "Please deploy the CloudFormation stack or configure LAMBDA_EXECUTION_ROLE_ARN_STAGING secret"
                echo "See infrastructure/lambda-execution-roles.yaml and infrastructure/deploy-roles.sh"
                exit 1
              fi
            fi
          fi
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
          echo "Using Lambda execution role: $ROLE_ARN"
      
      - name: Deploy Lambda function
        run: |
          JAR_FILE=$(find . -name "country-service-lambda-*.jar" | head -1)
          FUNCTION_NAME="${{ env.LAMBDA_FUNCTION_NAME }}-staging"
          echo "Deploying Lambda function: $FUNCTION_NAME"
          echo "JAR file: $JAR_FILE"
          
          # Check if function exists
          if aws lambda get-function --function-name "$FUNCTION_NAME" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "Function exists, updating code..."
            # Update Lambda function code
            aws lambda update-function-code \
              --function-name "$FUNCTION_NAME" \
              --zip-file "fileb://$JAR_FILE" \
              --region ${{ env.AWS_REGION }}
            
            # Wait for update to complete
            aws lambda wait function-updated \
              --function-name "$FUNCTION_NAME" \
              --region ${{ env.AWS_REGION }}
          else
            echo "Function does not exist, creating it..."
            # Create Lambda function
            # Use role ARN from step output (or secret if provided)
            EXECUTION_ROLE="${{ secrets.LAMBDA_EXECUTION_ROLE_ARN_STAGING }}"
            if [ -z "$EXECUTION_ROLE" ] || [ "$EXECUTION_ROLE" == "" ]; then
              EXECUTION_ROLE="${{ steps.lambda_role.outputs.role_arn }}"
            fi
            echo "Using Lambda execution role: $EXECUTION_ROLE"
            aws lambda create-function \
              --function-name "$FUNCTION_NAME" \
              --runtime java21 \
              --role "$EXECUTION_ROLE" \
              --handler com.example.country.adapters.lambda.LambdaEntryPoint::handleRequest \
              --zip-file "fileb://$JAR_FILE" \
              --timeout 30 \
              --memory-size 512 \
              --architectures x86_64 \
              --region ${{ env.AWS_REGION }}
            
            # Wait for function to be active
            aws lambda wait function-active \
              --function-name "$FUNCTION_NAME" \
              --region ${{ env.AWS_REGION }}
          fi
      
      - name: Update Lambda environment variables
        run: |
          aws lambda update-function-configuration \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }}-staging \
            --environment "Variables={AWS_REGION=${{ env.AWS_REGION }},API_KEY=${{ secrets.API_KEY }},DYNAMODB_TABLE_NAME=Countries}" \
            --region ${{ env.AWS_REGION }}
      
      - name: Check if smoke tests should run
        id: check_smoke_tests
        env:
          API_GATEWAY_URL: ${{ secrets.API_GATEWAY_URL_STAGING }}
        run: |
          if [ -n "$API_GATEWAY_URL" ] && [ "$API_GATEWAY_URL" != "" ]; then
            echo "run_smoke_tests=true" >> $GITHUB_OUTPUT
          else
            echo "run_smoke_tests=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Install jq (for JSON validation)
        if: steps.check_smoke_tests.outputs.run_smoke_tests == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          
      - name: Run smoke tests
        if: steps.check_smoke_tests.outputs.run_smoke_tests == 'true'
        env:
          API_GATEWAY_URL: ${{ secrets.API_GATEWAY_URL_STAGING }}
          API_KEY: ${{ secrets.API_KEY }}
        run: |
          echo "Running smoke tests against staging environment..."
          echo "API Gateway URL: $API_GATEWAY_URL"
          
          # Wait for Lambda to be ready after configuration update
          echo "Waiting for Lambda to be ready..."
          sleep 5
          
          # Test 1: Health check - GET /api/v1/countries (should return 200 with JSON array)
          echo "Test 1: GET /api/v1/countries"
          RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "$API_GATEWAY_URL/api/v1/countries" \
            -H "X-API-KEY: $API_KEY" \
            -H "Content-Type: application/json" || echo -e "\n000")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          echo "HTTP Status: $HTTP_CODE"
          echo "Response body (first 200 chars): ${BODY:0:200}"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "❌ Smoke test failed: Expected HTTP 200, got $HTTP_CODE"
            echo "Full response: $BODY"
            exit 1
          fi
          
          # Validate response is valid JSON array
          if ! echo "$BODY" | jq -e '. | type == "array"' > /dev/null 2>&1; then
            echo "❌ Smoke test failed: Response is not a valid JSON array"
            echo "Response: $BODY"
            exit 1
          fi
          
          echo "✅ Smoke test 1 passed: GET /api/v1/countries returned valid JSON array"
          
          # Test 2: Authentication check - request without API key should return 401
          echo ""
          echo "Test 2: Authentication validation (no API key)"
          AUTH_RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "$API_GATEWAY_URL/api/v1/countries" \
            -H "Content-Type: application/json" || echo -e "\n000")
          
          AUTH_HTTP_CODE=$(echo "$AUTH_RESPONSE" | tail -n1)
          
          if [ "$AUTH_HTTP_CODE" == "401" ]; then
            echo "✅ Smoke test 2 passed: Authentication is working (401 without API key)"
          else
            echo "⚠️  Warning: Expected HTTP 401 for unauthenticated request, got $AUTH_HTTP_CODE"
            echo "This may indicate authentication is not properly configured"
          fi
          
          echo ""
          echo "✅ All smoke tests passed successfully!"
          
      - name: Smoke tests skipped
        if: steps.check_smoke_tests.outputs.run_smoke_tests == 'false'
        run: |
          echo "⚠️  Smoke tests skipped: API_GATEWAY_URL_STAGING secret not configured"
          echo "To enable smoke tests, add API_GATEWAY_URL_STAGING secret to your GitHub repository"
          echo "The secret should contain the full API Gateway URL (e.g., https://abc123.execute-api.us-east-1.amazonaws.com)"

  deploy-production:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'
    environment:
      name: production
      # URL can be configured in GitHub Environment settings if needed
      # Require manual approval for production - configured in GitHub repository settings under Environments
    
    steps:
      - uses: actions/checkout@v5
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN_PRODUCTION }}
          role-session-name: GitHubActions-Deploy-Production
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Download Lambda package
        uses: actions/download-artifact@v5
        with:
          name: lambda-package
          path: .
      
      - name: Get Lambda execution role ARN
        id: lambda_role
        run: |
          # Use secret if provided, otherwise get from CloudFormation stack or IAM
          if [ -n "${{ secrets.LAMBDA_EXECUTION_ROLE_ARN_PRODUCTION }}" ] && [ "${{ secrets.LAMBDA_EXECUTION_ROLE_ARN_PRODUCTION }}" != "" ]; then
            ROLE_ARN="${{ secrets.LAMBDA_EXECUTION_ROLE_ARN_PRODUCTION }}"
            echo "Using role ARN from secret: $ROLE_ARN"
          else
            # Try to get from CloudFormation stack
            STACK_NAME="country-service-lambda-execution-roles"
            if aws cloudformation describe-stacks --stack-name "$STACK_NAME" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
              echo "Getting role ARN from CloudFormation stack..."
              ROLE_ARN=$(aws cloudformation describe-stacks \
                --stack-name "$STACK_NAME" \
                --region ${{ env.AWS_REGION }} \
                --query 'Stacks[0].Outputs[?OutputKey==`LambdaExecutionRoleArnProduction`].OutputValue' \
                --output text)
              echo "Got role ARN from CloudFormation: $ROLE_ARN"
            else
              # Fallback: try to get from IAM directly
              ROLE_NAME="country-service-lambda-execution-production"
              if aws iam get-role --role-name "$ROLE_NAME" >/dev/null 2>&1; then
                ROLE_ARN=$(aws iam get-role --role-name "$ROLE_NAME" --query 'Role.Arn' --output text)
                echo "Got role ARN from IAM: $ROLE_ARN"
              else
                echo "❌ Error: Lambda execution role not found"
                echo "Please deploy the CloudFormation stack or configure LAMBDA_EXECUTION_ROLE_ARN_PRODUCTION secret"
                echo "See infrastructure/lambda-execution-roles.yaml and infrastructure/deploy-roles.sh"
                exit 1
              fi
            fi
          fi
          echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
          echo "Using Lambda execution role: $ROLE_ARN"
      
      - name: Deploy Lambda function
        run: |
          JAR_FILE=$(find . -name "country-service-lambda-*.jar" | head -1)
          FUNCTION_NAME="${{ env.LAMBDA_FUNCTION_NAME }}-production"
          echo "Deploying Lambda function: $FUNCTION_NAME"
          echo "JAR file: $JAR_FILE"
          
          # Check if function exists
          if aws lambda get-function --function-name "$FUNCTION_NAME" --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "Function exists, updating code..."
            # Update Lambda function code
            aws lambda update-function-code \
              --function-name "$FUNCTION_NAME" \
              --zip-file "fileb://$JAR_FILE" \
              --region ${{ env.AWS_REGION }}
            
            # Wait for update to complete
            aws lambda wait function-updated \
              --function-name "$FUNCTION_NAME" \
              --region ${{ env.AWS_REGION }}
          else
            echo "Function does not exist, creating it..."
            # Create Lambda function
            # Use role ARN from step output
            EXECUTION_ROLE="${{ steps.lambda_role.outputs.role_arn }}"
            if [ -z "$EXECUTION_ROLE" ] || [ "$EXECUTION_ROLE" == "" ]; then
              echo "❌ Error: Lambda execution role ARN not found"
              echo "Please deploy the CloudFormation stack or configure LAMBDA_EXECUTION_ROLE_ARN_PRODUCTION secret"
              exit 1
            fi
            echo "Using Lambda execution role: $EXECUTION_ROLE"
            aws lambda create-function \
              --function-name "$FUNCTION_NAME" \
              --runtime java21 \
              --role "$EXECUTION_ROLE" \
              --handler com.example.country.adapters.lambda.LambdaEntryPoint::handleRequest \
              --zip-file "fileb://$JAR_FILE" \
              --timeout 30 \
              --memory-size 512 \
              --architectures x86_64 \
              --region ${{ env.AWS_REGION }}
            
            # Wait for function to be active
            aws lambda wait function-active \
              --function-name "$FUNCTION_NAME" \
              --region ${{ env.AWS_REGION }}
          fi
      
      - name: Update Lambda environment variables
        run: |
          aws lambda update-function-configuration \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }}-production \
            --environment "Variables={AWS_REGION=${{ env.AWS_REGION }},API_KEY=${{ secrets.API_KEY_PROD }},DYNAMODB_TABLE_NAME=Countries}" \
            --region ${{ env.AWS_REGION }}
      
      - name: Check if smoke tests should run
        id: check_smoke_tests
        env:
          API_GATEWAY_URL: ${{ secrets.API_GATEWAY_URL_PRODUCTION }}
        run: |
          if [ -n "$API_GATEWAY_URL" ] && [ "$API_GATEWAY_URL" != "" ]; then
            echo "run_smoke_tests=true" >> $GITHUB_OUTPUT
          else
            echo "run_smoke_tests=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Install jq (for JSON validation)
        if: steps.check_smoke_tests.outputs.run_smoke_tests == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          
      - name: Run smoke tests
        if: steps.check_smoke_tests.outputs.run_smoke_tests == 'true'
        env:
          API_GATEWAY_URL: ${{ secrets.API_GATEWAY_URL_PRODUCTION }}
          API_KEY: ${{ secrets.API_KEY_PROD }}
        run: |
          echo "Running smoke tests against production environment..."
          echo "API Gateway URL: $API_GATEWAY_URL"
          
          # Wait for Lambda to be ready after configuration update
          echo "Waiting for Lambda to be ready..."
          sleep 5
          
          # Test 1: Health check - GET /api/v1/countries (should return 200 with JSON array)
          echo "Test 1: GET /api/v1/countries"
          RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "$API_GATEWAY_URL/api/v1/countries" \
            -H "X-API-KEY: $API_KEY" \
            -H "Content-Type: application/json" || echo -e "\n000")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          echo "HTTP Status: $HTTP_CODE"
          echo "Response body (first 200 chars): ${BODY:0:200}"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "❌ Smoke test failed: Expected HTTP 200, got $HTTP_CODE"
            echo "Full response: $BODY"
            exit 1
          fi
          
          # Validate response is valid JSON array
          if ! echo "$BODY" | jq -e '. | type == "array"' > /dev/null 2>&1; then
            echo "❌ Smoke test failed: Response is not a valid JSON array"
            echo "Response: $BODY"
            exit 1
          fi
          
          echo "✅ Smoke test 1 passed: GET /api/v1/countries returned valid JSON array"
          
          # Test 2: Authentication check - request without API key should return 401
          echo ""
          echo "Test 2: Authentication validation (no API key)"
          AUTH_RESPONSE=$(curl -s -w "\n%{http_code}" -X GET "$API_GATEWAY_URL/api/v1/countries" \
            -H "Content-Type: application/json" || echo -e "\n000")
          
          AUTH_HTTP_CODE=$(echo "$AUTH_RESPONSE" | tail -n1)
          
          if [ "$AUTH_HTTP_CODE" == "401" ]; then
            echo "✅ Smoke test 2 passed: Authentication is working (401 without API key)"
          else
            echo "⚠️  Warning: Expected HTTP 401 for unauthenticated request, got $AUTH_HTTP_CODE"
            echo "This may indicate authentication is not properly configured"
          fi
          
          echo ""
          echo "✅ All smoke tests passed successfully!"
          
      - name: Smoke tests skipped
        if: steps.check_smoke_tests.outputs.run_smoke_tests == 'false'
        run: |
          echo "⚠️  Smoke tests skipped: API_GATEWAY_URL_PRODUCTION secret not configured"
          echo "To enable smoke tests, add API_GATEWAY_URL_PRODUCTION secret to your GitHub repository"
          echo "The secret should contain the full API Gateway URL (e.g., https://abc123.execute-api.us-east-1.amazonaws.com)"

